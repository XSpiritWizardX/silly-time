Add an `UPGRADE_CATALOG` (e.g., `speed`, `magnet`, `double_jump`) with base cost, scaling factor, max level, and optional effect metadata. Implement `apply_upgrade(state, upgrade_id)` as a pure function that: validates `upgrade_id`, computes current level and next cost, checks `coins` and max level, decrements coins, increments upgrade level, and returns the updated state. Raise explicit domain errors for `unknown_upgrade`, `insufficient_coins`, and `max_level_reached` so the API can map them to clear 400 responses.
